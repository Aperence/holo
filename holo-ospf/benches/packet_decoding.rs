use std::hint::black_box;
use std::net::Ipv4Addr;
use std::sync::LazyLock as Lazy;

use bytes::Bytes;
use criterion::{Criterion, criterion_group, criterion_main};
use holo_ospf::packet::*;
use holo_ospf::version::Ospfv2;
use holo_utils::ip::AddressFamily;

static BYTES: Lazy<Vec<u8>> = Lazy::new(|| {
    vec![
        0x02, 0x04, 0x00, 0x78, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x01,
        0x40, 0xa1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x31, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x02, 0x37, 0xf4, 0x00, 0x24,
        0x01, 0x00, 0x00, 0x01, 0x0a, 0x00, 0x01, 0x00, 0xff, 0xff, 0xff, 0x00,
        0x03, 0x00, 0x00, 0x0a, 0x00, 0x31, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x01, 0xd2, 0x7a, 0x00, 0x1c,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x02, 0x03,
        0x0a, 0x00, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x01,
        0xfa, 0x44, 0x00, 0x1c, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x0a,
    ]
});

fn packet_decode(n: u64) {
    for _ in 0..n {
        let mut buf = Bytes::copy_from_slice(&BYTES);
        let src = Ipv4Addr::UNSPECIFIED;
        let _ = Packet::<Ospfv2>::decode(
            AddressFamily::Ipv4,
            &mut buf,
            None,
            &src.into(),
        )
        .unwrap();
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("Packet decode", |b| {
        b.iter(|| packet_decode(black_box(10000)))
    });
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
